<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Weathermap QuickEdit</title>

</head>
<body>
  <link rel="stylesheet" href="index.css">
<div id="topMenu">
  <span style="margin-right:20px; font-weight: bold;">Weathermap QuickEdit</span>
  <span style="">Config file : </span>
  <select id="configSelector"></select>
  &nbsp;
  <button id="openBtn">ðŸ“‚ Open</button>
  <button id="saveBtn">ðŸ’¾ Save</button>
  <input type="checkbox" id="gridEnabled" value="true" checked />&nbsp;<button>Grid&nbsp;<input type="number" id="gridSizeInput" value="40" min="10" max="200" style="width:60px;"></button>
  <button id="selectModeBtn">Select Mode</button>
  
</div>

<svg id="map">
    <defs>
    <g id="xmarker">
      <line x1="-4" y1="-4" x2="4" y2="4" stroke="#555555" stroke-width="1"/>
      <line x1="-4" y1="4" x2="4" y2="-4" stroke="#555555" stroke-width="1"/>
    </g>
  </defs>
</svg>
<div id="tooltip" style="white-space: pre;position:absolute; display:none; background:#fff; border:1px solid #333; padding:4px 8px; font-size:12px; pointer-events:none; z-index:100;"></div>
<div id="propertiesWindow" style="display:none; position:absolute; top:100px; left:100px; min-width:220px; background:#fff; border:2px solid #0074D9; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,0.12); z-index:900;">
  <div id="propertiesHeader" style="cursor:move; background:#0074D9; color:#fff; padding:8px; border-radius:8px 8px 0 0;">
    Node Properties
    <button id="closePropertiesBtn" style="float:right; background:none; border:none; color:#fff; font-size:16px; cursor:pointer;">Ã—</button>
  </div>
  <div id="propertiesContent" style="padding:12px;"></div>
</div>
<div style="opacity: 0;"><svg id="buffer"></svg></div>
<script>
let mapData = null;
let dragging = null;
let gridSize = 32; // You can make this configurable via UI
let snapToGridEnabled = false; // You can make this configurable via UI
const imgsizes = []; // to store preloaded icon sizes
const labelsizes = []; // to store text label sizes

let selectMode = false;
let selectedNodes = new Set();
let multiDrag = null; // for multi-node dragging

// Preload image and return a Promise that resolves when loaded
async function preloadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.crossOrigin = 'Anonymous' // to avoid CORS if used with Canvas
    img.src = src
    img.onload = () => {
      resolve({ src, width: img.naturalWidth, height: img.naturalHeight })
    }
    img.onerror = e => {
      reject(e)
    }
  })
}

async function fetchConfigFiles() {
  const res = await fetch('/config-files');
  const files = await res.json();
  const selector = document.getElementById('configSelector');
  selector.innerHTML = '';
  files.forEach(file => {
    const option = document.createElement('option');
    option.value = file;
    option.textContent = file;
    selector.appendChild(option);
  });
}

async function preloadNodeIconsAndSizes() {
  const nodeslist = Object.values(mapData.nodes || {});
  // Get unique icon filenames
  const iconFiles = [...new Set(nodeslist.map(node => node.icon))];
  for (const file of iconFiles) {
    try {
      const imgInfo = await preloadImage(`${file}`);
      imgsizes.push(imgInfo);
    } catch (e) {
      console.warn('Failed to load', file);
    }
  }
}

function drawGridLayer(svg, width, height, gridSize) {
  // Remove old grid if exists
  const oldGrid = svg.querySelector('.gridlayer');
  if (oldGrid) oldGrid.remove();

  const gridLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  gridLayer.setAttribute('class', 'gridlayer');

  for (let x = 0; x < width; x += gridSize) {
    for (let y = 0; y < height; y += gridSize) {
      const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      dot.setAttribute('cx', x);
      dot.setAttribute('cy', y);
      dot.setAttribute('r', 2);
      dot.setAttribute('fill', '#ddd');
      gridLayer.appendChild(dot);
    }
  }
  svg.appendChild(gridLayer);
}

function snapToGrid(val, gridSize) {
  return Math.round(val / gridSize) * gridSize;
}

function addLinkMidMarker(svg, points, linkName, updateOnly = false) {
  // points: array of {x, y}
  // 1. Calculate total length
  let totalLength = 0;
  for (let i = 1; i < points.length; i++) {
    const dx = points[i].x - points[i-1].x;
    const dy = points[i].y - points[i-1].y;
    totalLength += Math.sqrt(dx*dx + dy*dy);
  }
  // 2. Find midpoint position
  let halfLength = totalLength / 2;
  let accLength = 0;
  let mid = {x: points[0].x, y: points[0].y};
  for (let i = 1; i < points.length; i++) {
    const dx = points[i].x - points[i-1].x;
    const dy = points[i].y - points[i-1].y;
    const segLength = Math.sqrt(dx*dx + dy*dy);
    if (accLength + segLength >= halfLength) {
      const ratio = (halfLength - accLength) / segLength;
      mid.x = points[i-1].x + dx * ratio;
      mid.y = points[i-1].y + dy * ratio;
      break;
    }
    accLength += segLength;
  }
  // 3. Draw marker
  if (!updateOnly) {
    // Draw a new marker
    const marker = document.createElementNS('http://www.w3.org/2000/svg','use');
    marker.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#xmarker');
    marker.setAttribute('x', mid.x);
    marker.setAttribute('y', mid.y);
    marker.setAttribute('class', 'link-mid-marker');
    marker.setAttribute('id', linkName + '_midmarker');
    svg.appendChild(marker);
  } else {
    const existingMarker = svg.getElementById(linkName + '_midmarker');
    if (existingMarker) {
      existingMarker.setAttribute('x', mid.x);
      existingMarker.setAttribute('y', mid.y);
      return;
    }
  }

}

function getEndpointWithOffset(endpoint) { // endpoint as Array
  // endpoint: [nodeName, offsetStr?]
  const nodeName = endpoint[0];
  const offsetStr = endpoint[1];
  const node = mapData.nodes[nodeName];
  if (!node || !node.position) return { x: 0, y: 0 };
  if (!offsetStr) return { x: node.position.x, y: node.position.y };
  const directions_x = { 'N':0, 'NE':1, 'E':1, 'SE':1, 'S':0, 'SW':-1, 'W':-1, 'NW':-1 };
  const directions_y = { 'N':-1, 'NE':-1, 'E':0, 'SE':1, 'S':1, 'SW':1, 'W':0, 'NW':-1 };
  const offset = offsetStr.split(/([+-]?\d+)/).filter(Boolean);
  const iconWidth = imgsizes.find(img => img.src.endsWith(node.icon))?.width || 0;
  const iconHeight = imgsizes.find(img => img.src.endsWith(node.icon))?.height || 0;
  const x = node.position.x + (directions_x[offset[0]] || 0) * (parseInt(offset[1]) || 0) * iconWidth / 200;
  const y = node.position.y + (directions_y[offset[0]] || 0) * (parseInt(offset[1]) || 0) * iconHeight / 200;
  return { x, y };
}

function getEndpointOffset(endpoint) { // endpoint as String
  // endpoint: [nodeName, offsetStr?]
  if (typeof endpoint === 'string') {
    endpoint = endpoint.split(':');
  } 
  const nodeName = endpoint[0];
  offsetStr = endpoint[1];
  const node = mapData.nodes[nodeName];
  if (!node || !node.position) return { x: 0, y: 0 };
  if (!offsetStr) {
    // if no offset, return node position
    return { x: 0, y: 0 };
  }
  const directions_x = { 'N':0, 'NE':1, 'E':1, 'SE':1, 'S':0, 'SW':-1, 'W':-1, 'NW':-1 };
  const directions_y = { 'N':-1, 'NE':-1, 'E':0, 'SE':1, 'S':1, 'SW':1, 'W':0, 'NW':-1 };
  const offset = offsetStr.split(/([+-]?\d+)/).filter(Boolean);
  const iconWidth = imgsizes.find(img => img.src.endsWith(node.icon))?.width || 0;
  const iconHeight = imgsizes.find(img => img.src.endsWith(node.icon))?.height || 0;
  const x = (directions_x[offset[0]] || 0) * (parseInt(offset[1]) || 0) * iconWidth / 200;
  const y = (directions_y[offset[0]] || 0) * (parseInt(offset[1]) || 0) * iconHeight / 200;
  return { x, y };
}

function showPropertiesWindow(obj, title = "Properties") {
  if (!obj) return;
  const win = document.getElementById('propertiesWindow');
  const content = document.getElementById('propertiesContent');
  const header = document.getElementById('propertiesHeader');
  content.innerHTML = '';
  header.childNodes[0].textContent = title; // Set window title

  Object.entries(obj).forEach(([key, value]) => {
    const row = document.createElement('div');
    row.style.marginBottom = '6px';
    const label = document.createElement('span');
    label.textContent = key + ': ';
    label.style.fontWeight = 'bold';
    row.appendChild(label);

    const input = document.createElement('input');
    input.value = typeof value === 'object' ? JSON.stringify(value) : value;
    input.style.width = '120px';
    // input readonly
    input.setAttribute('readonly', 'readonly');
    input.dataset.key = key;
    /*input.onchange = function() {
      try {
        obj[key] = JSON.parse(this.value);
      } catch {
        obj[key] = this.value;
      }
    };*/
    row.appendChild(input);
    content.appendChild(row);
  });
  win.style.display = 'block';
  win.style.left = '100px';
  win.style.top = '100px';
}

// Show properties window on node click
function addNodeClickProperties(nodes) {
  Object.entries(nodes).forEach(([name, props]) => {
    const g = document.getElementById('map').getElementById(name);
    if (g) {
      g.addEventListener('click', function(e) {
        e.stopPropagation();
        if (selectMode) {
          if (selectedNodes.has(name)) {
            selectedNodes.delete(name);
            g.classList.remove('selected-node');
          } else {
            selectedNodes.add(name);
            g.classList.add('selected-node');
          }
        } else {
          showPropertiesWindow(mapData.nodes[name], "Node Properties: " + name);
        }
      });
    }
  });
}

// Show properties window on link click
function addLinkClickProperties(links) {
  Object.entries(links).forEach(([name, props]) => {
    const g = document.getElementById('map').getElementById(name);
    if (g) {
      g.addEventListener('click', function(e) {
        e.stopPropagation();
        showPropertiesWindow(mapData.links[name], "Link Properties: " + name);
      });
    }
  });
}

async function LoadAndDraw() {
  await Load();
  if (mapData) {
    Draw();
  } else {
    document.body.textContent = 'Erreur: donnÃ©es de la carte non chargÃ©es.';
  }  
}

async function Load() {
  const res = await fetch('/map.json');
  if (!res.ok) {
    document.body.textContent = 'Erreur: ' + (await res.text());
    return;
  }
  mapData = await res.json();
}
async function Draw() {

  await preloadNodeIconsAndSizes();

  const svg = document.getElementById('map');
  //svg.innerHTML = ''; // clear

  const nodes = mapData.nodes || {};
  const links = mapData.links || {};

  const svg_width = mapData.globals.filter(obj=>obj.key==='WIDTH')[0].value;
  const svg_height = mapData.globals.filter(obj=>obj.key==='HEIGHT')[0].value;  
  svg.style.width = svg_width+"px";
  svg.style.height = svg_height+"px";

  // display background image if exists
  if (mapData.globals.filter(obj=>obj.key==='BACKGROUND')[0]) {
    const bgImage = mapData.globals.filter(obj=>obj.key==='BACKGROUND')[0].value;
    const bg = document.createElementNS('http://www.w3.org/2000/svg','image');
    bg.setAttribute('href', bgImage);
    svg.appendChild(bg);
  }

  // draw grid layer
  drawGridLayer(svg, svg_width, svg_height, gridSize);

  // create a layer for vias
  const vialayer = document.createElementNS('http://www.w3.org/2000/svg','g');
  vialayer.setAttribute('class', 'vias');

  // draw links
  Object.entries(links).forEach(([name, props]) => {
  let a = props.endpoint_a, b = props.endpoint_b;
  if (!a || !b) return;
  const na = nodes[a[0]], nb = nodes[b[0]];
  if (!na || !nb || !na.position || !nb.position) return;
  
  // Build link path : start â†’ vias â†’ end
  const points = []; 
  const pointsArray = []; // for mid marker calculation

  endpoint = getEndpointWithOffset(a); // get endpoint and offset
  points.push(`${endpoint.x},${endpoint.y}`); // starting point with offset
  pointsArray.push({x: endpoint.x, y: endpoint.y});

  if (props.vias && props.vias.length) {
    var viaindex = 1;
    props.vias.forEach(v => {
      points.push(`${v.x},${v.y}`);
      pointsArray.push({x: v.x, y: v.y});

      const vianchor = document.createElementNS('http://www.w3.org/2000/svg','circle');
      const x = v.x, y = v.y;
      const w = 12, h = 12;
      vianchor.setAttribute('id',`${name}#${viaindex}`);
      vianchor.setAttribute('cx', x);
      vianchor.setAttribute('cy', y);
      vianchor.setAttribute('r', 6);
      vianchor.setAttribute('class', 'via');
      vianchor.setAttribute('style', "fill:#777;stroke:#0;stroke-width:1");

      vianchor.addEventListener('mouseover', (e) => {
        e.stopPropagation(); // prevent dragging nodes
        const tooltip = document.getElementById('tooltip');
        tooltip.textContent = `Via ${e.target.id}: ${e.target.cx.baseVal.value},${e.target.cy.baseVal.value}`;
        tooltip.style.left = (e.pageX + 10) + 'px';
        tooltip.style.top = (e.pageY + 10) + 'px';
        tooltip.style.display = 'block';
      });

      vianchor.addEventListener('mouseout', (e) => {
        document.getElementById('tooltip').style.display = 'none'; // hide tooltip
      });

      vianchor.addEventListener('mousedown', (e) => {
        e.stopPropagation(); // prevent dragging nodes
        dragging = { name: e.target.id, offsetX: e.offsetX, offsetY: e.offsetY, w, h, draggedtype: 'via' };
      });
      vialayer.appendChild(vianchor);
      viaindex++;
    });
  }
  
  endpoint = getEndpointWithOffset(b); // get endpoint and offset
  points.push(`${endpoint.x},${endpoint.y}`); // starting point with offset
  pointsArray.push({x: endpoint.x, y: endpoint.y});

  const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
  poly.setAttribute('points', points.join(' '));
  poly.setAttribute('style', "fill:none;stroke:#CCCCCC;stroke-width:8");
  poly.setAttribute('class', 'link');
  poly.setAttribute('id',name);
  poly.setAttribute('endpoint_a',`${a[0]}${a[1] ? ':'+a[1] : ''}`);
  poly.setAttribute('endpoint_b',`${b[0]}${b[1] ? ':'+b[1] : ''}`);

  poly.addEventListener('mouseover', (e) => {
    //e.stopPropagation(); // prevent dragging nodes
    if (dragging) return; // don't highlight if dragging
    //dragging = { name, offsetX: e.offsetX, offsetY: e.offsetY };
    e.target.style.stroke = '#FF4136'; // highlight link
      const tooltip = document.getElementById('tooltip');
      tooltip.textContent = `Link ${name}: ${a[0]} â†’ ${b[0]}`;
      if (props.vias && props.vias.length) {
        tooltip.textContent += `\r\n VIAs:\r\n ${props.vias.map(v => `(${v.x},${v.y})`).join('\r\n ')}`;
      }
      tooltip.style.left = (e.pageX + 10) + 'px';
      tooltip.style.top = (e.pageY + 10) + 'px';
      tooltip.style.display = 'block';
    });
    poly.addEventListener('mouseout', (e) => {
    e.target.style.stroke = '#CCCCCC'; // highlight link
    document.getElementById('tooltip').style.display = 'none'; // hide tooltip
  });

  
  svg.appendChild(poly);
  addLinkMidMarker(svg, pointsArray, name);
});
  svg.appendChild(vialayer);

  // draw nodes
  buffer = document.getElementById('buffer');  // use buffer SVG to measure label size
  Object.entries(nodes).forEach(([name, props]) => {
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('class','node');
    g.setAttribute('id',name);    
    const x = props.position?.x || 50;
    const y = props.position?.y || 50;
    var w = props.width ? parseInt(props.width) : 80;
    var h = props.height ? parseInt(props.height) : 16;

    // display node icon if exists
    if (props.icon) {
      // get preloaded image dimensions
      const iconWidth = imgsizes.find(img => img.src.endsWith(props.icon))?.width || w;
      const iconHeight = imgsizes.find(img => img.src.endsWith(props.icon))?.height || h;

      // create SVG image element      
      const icon = document.createElementNS('http://www.w3.org/2000/svg','image');
      icon.setAttribute('href', `/${props.icon}`);

      icon.setAttribute('x', x - iconWidth/2);
      icon.setAttribute('y', y - iconHeight/2);
      icon.setAttribute('width', iconWidth);
      icon.setAttribute('height', iconHeight);
      g.appendChild(icon);
    }
    // display label if exists
    if (props.label) {
      
      // if label has offset, split it
        var offset_x = 0, offset_y =0; 
        if (props.labeloffset) {
        // split label offset into words
        let offset = props.labeloffset.split(" ").filter(Boolean);


        if (offset.length > 1) {
          
          offset_x = parseInt(offset[0]) || 0;
          offset_y = parseInt(offset[1]) || 0;
        }
      }
      // create SVG label bounding box
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('id','rect');

      // create SVG text element for label
      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', x + offset_x);
      label.setAttribute('y', y + offset_y);
      label.setAttribute('class', 'label');

      label.textContent = props.label || name;

      g.appendChild(rect);
      
      
      buffer.appendChild(label); 
      labelBox = label.getBBox();
      label.remove(); // remove from buffer, we only need the size
      g.appendChild(label);  
      // adjust rect width to fit label
      const labelPaddingW = 6; const labelPaddingH = 2// padding around label
      w = labelBox.width + labelPaddingW; 
      h = labelBox.height + labelPaddingH; 
      labelsizes.push({ name, width: w, height: h });


      rect.setAttribute('x', x - w/2 + offset_x);
      rect.setAttribute('y', y - h/2 + offset_y);
      rect.setAttribute('width', w); // add some padding
      rect.setAttribute('height', h); // keep height from props

      rect.addEventListener('mousedown', (e) => {
        dragging = { name, offsetX: e.offsetX , offsetY: e.offsetY , w , h, draggedtype: 'node' };
      });

    }
    svg.appendChild(g);
  });
  buffer.innerHTML = ""; // clear buffer after measuring boxes
  // Add click properties to nodes and links
  addNodeClickProperties(nodes);
  addLinkClickProperties(links);
}

document.addEventListener('mousemove', function(e) {             // Dragging multiple selected nodes
  if (!multiDrag) return;
  const svg = document.getElementById('map');
  const dx = e.clientX - multiDrag.startX;
  const dy = e.clientY - multiDrag.startY;
  multiDrag.nodes.forEach(n => {
    // Snap if enabled
    let newX = snapToGridEnabled ? snapToGrid(n.x + dx, gridSize) : n.x + dx;
    let newY = snapToGridEnabled ? snapToGrid(n.y + dy, gridSize) : n.y + dy;
    mapData.nodes[n.name].position.x = newX;
    mapData.nodes[n.name].position.y = newY;
    // Update SVG node position
    const g = svg.getElementById(n.name);
    if (g) {
      // If icon, update icon and label positions
      const node = mapData.nodes[n.name];
      if (node.icon) {
        g.childNodes[0].setAttribute('x', newX - imgsizes.find(img => img.src.endsWith(node.icon))?.width / 2 );
        g.childNodes[0].setAttribute('y', newY - imgsizes.find(img => img.src.endsWith(node.icon))?.height / 2 );
        g.childNodes[1].setAttribute('x', newX - labelsizes.find(lab => lab.name.endsWith(n.name))?.width / 2 ); 
        g.childNodes[1].setAttribute('y', newY - labelsizes.find(lab => lab.name.endsWith(n.name))?.height / 2);
        g.childNodes[2].setAttribute('x', newX );
        g.childNodes[2].setAttribute('y', newY );
      } else {
        g.childNodes[0].setAttribute('x', newX - labelsizes.find(lab => lab.name.endsWith(n.name))?.width / 2);
        g.childNodes[0].setAttribute('y', newY - labelsizes.find(lab => lab.name.endsWith(n.name))?.height / 2);
        g.childNodes[1].setAttribute('x', newX );
        g.childNodes[1].setAttribute('y', newY );
      }
    }

  // Optionally, redraw links here if needed
      var linkFilter = '[endpoint_a="' + n.name +'"],[endpoint_a^="' + n.name +':"]';
      var links = svg.querySelectorAll(linkFilter);
      links.forEach( (poly) => { 
        endpoint_name = poly.getAttribute('endpoint_a');
        endpoint_offset = getEndpointOffset(endpoint_name);
        poly.points[0].x=newX+endpoint_offset.x;
        poly.points[0].y=newY+endpoint_offset.y; 
        addLinkMidMarker(svg, Array.from(poly.points).map(p => ({x: p.x, y: p.y})), poly.id, true);
      });

      linkFilter = '[endpoint_b="' + n.name +'"],[endpoint_b^="' + n.name +':"]';
      links = svg.querySelectorAll(linkFilter);
      links.forEach( (poly) => { 
        endpoint_name = poly.getAttribute('endpoint_b');
        endpoint_offset = getEndpointOffset(endpoint_name); 
        poly.points[poly.points.length-1].x=newX + endpoint_offset.x ;
        poly.points[poly.points.length-1].y=newY + endpoint_offset.y ; 
        addLinkMidMarker(svg, Array.from(poly.points).map(p => ({x: p.x, y: p.y})), poly.id, true);
      });
  });
});

document.addEventListener('mousemove', (e) => {         // Simple dragging of single via or node
  ///////////////////////////////////////////////////////////////
  // Simple dragging of single via or node
  ///////////////////////////////////////////////////////////////

  if (!dragging || multiDrag) return;
  const svg = document.getElementById('map');
  const svgnode = svg.getElementById(dragging.name);

  // Alt disables grid snapping
  const snap = snapToGridEnabled && !e.ctrlKey;

  switch (dragging.draggedtype) {
    case 'via':
      // update via position
      const via = svgnode;
      var newX = snap ? snapToGrid(e.offsetX, gridSize) : e.offsetX;
      var newY = snap ? snapToGrid(e.offsetY, gridSize) : e.offsetY;

      via.setAttribute('cx', newX);
      via.setAttribute('cy', newY);
      // redraw related links
      var linkFilter = '[id="' + dragging.name.split('#')[0] + '"]';
      var links = svg.querySelectorAll(linkFilter);
      links.forEach( (poly) => {
        const points = poly.points;
      
        const viaIndex = dragging.name.split('#')[1]; // get via index from id
        if (points.length > viaIndex) {
          points[viaIndex].x = newX ; // update via point
          points[viaIndex].y = newY ;
          addLinkMidMarker(svg, Array.from(points).map(p => ({x: p.x, y: p.y})), poly.id, true);
        }
      });
      //update mapData
      const linkName = dragging.name.split('#')[0];
      if (mapData.links[linkName]) {
        const viaIndex = parseInt(dragging.name.split('#')[1]) - 1; // convert to zero-based index
        if (!mapData.links[linkName].vias) { return ;} // ensure vias exist
        if (mapData.links[linkName].vias.length > viaIndex) {
          mapData.links[linkName].vias[viaIndex].x = newX ;
          mapData.links[linkName].vias[viaIndex].y = newY ;   
        }
      }
      break;
    case 'node':
      // update node position
      const node = mapData.nodes[dragging.name];
      var newX = snap ? snapToGrid(e.offsetX, gridSize) : e.offsetX;
      var newY = snap ? snapToGrid(e.offsetY, gridSize) : e.offsetY;

      node.position = { x: newX , y: newY  };
      // redraw node
      // check if node has icon
      if (node.icon) {
        svgnode.childNodes[0].setAttribute('x', newX - imgsizes.find(img => img.src.endsWith(node.icon))?.width / 2 );
        svgnode.childNodes[0].setAttribute('y', newY - imgsizes.find(img => img.src.endsWith(node.icon))?.height / 2 );
        svgnode.childNodes[1].setAttribute('x', newX - dragging.w/2);
        svgnode.childNodes[1].setAttribute('y', newY - dragging.h/2);
        svgnode.childNodes[2].setAttribute('x', newX );
        svgnode.childNodes[2].setAttribute('y', newY );
      } else {
        svgnode.childNodes[0].setAttribute('x', newX - dragging.w/2);
        svgnode.childNodes[0].setAttribute('y', newY - dragging.h/2);
        svgnode.childNodes[1].setAttribute('x', newX  );
        svgnode.childNodes[1].setAttribute('y', newY  );
      }

      //redraw related links
      var linkFilter = '[endpoint_a="' + dragging.name +'"],[endpoint_a^="' + dragging.name +':"]';
      var links = svg.querySelectorAll(linkFilter);
      links.forEach( (poly) => { 
        endpoint_name = poly.getAttribute('endpoint_a');
        endpoint_offset = getEndpointOffset(endpoint_name);
        poly.points[0].x=newX+endpoint_offset.x;
        poly.points[0].y=newY+endpoint_offset.y; 
        addLinkMidMarker(svg, Array.from(poly.points).map(p => ({x: p.x, y: p.y})), poly.id, true);
      });

      linkFilter = '[endpoint_b="' + dragging.name +'"],[endpoint_b^="' + dragging.name +':"]';
      links = svg.querySelectorAll(linkFilter);
      links.forEach( (poly) => { 
        endpoint_name = poly.getAttribute('endpoint_b');
        endpoint_offset = getEndpointOffset(endpoint_name); 
        poly.points[poly.points.length-1].x=newX + endpoint_offset.x ;
        poly.points[poly.points.length-1].y=newY + endpoint_offset.y ; 
        addLinkMidMarker(svg, Array.from(poly.points).map(p => ({x: p.x, y: p.y})), poly.id, true);
      });
      break;
  }

  //loadAndDraw(); // redraw
});

document.addEventListener('mouseup', () => { dragging = null; multiDrag = null;});

document.getElementById('openBtn').addEventListener('click', async () => {
  const selector = document.getElementById('configSelector');
  const file = selector.value;
  if (!file) return;
  const res = await fetch(`/load-config?file=${encodeURIComponent(file)}`);
  mapData = await res.json();
  Draw();
});

document.getElementById('saveBtn').addEventListener('click', async () => {
  const res = await fetch('/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(mapData)
  });
  if (res.ok) {
    alert('Configuration sauvegardÃ©e.');
  } else {
    alert('Erreur sauvegarde: ' + await res.text());
  }
});

document.getElementById('selectModeBtn').addEventListener('click', function() {
  selectMode = !selectMode;
  this.style.background = selectMode ? '#FFDC00' : '';
  // Optionally clear selection when leaving select mode
  if (!selectMode) {
    selectedNodes.forEach(name => {
      const g = document.getElementById('map').getElementById(name);
      if (g) g.classList.remove('selected-node');
    });
    selectedNodes.clear();
  }
});

document.addEventListener('mousedown', function(e) {
  ///////////////////////////////////////////////////////////////////
  // Start multi-node drag if in select mode
  ///////////////////////////////////////////////////////////////////
  if (!selectMode) return;
  // Only start drag if clicking a selected node
  const svg = document.getElementById('map');
  const target = e.target.closest('.node');
  if (target && selectedNodes.has(target.id)) {
    // Record initial positions and mouse offset
    multiDrag = {
      startX: e.clientX,
      startY: e.clientY,
      nodes: Array.from(selectedNodes).map(name => {
        const node = mapData.nodes[name];
        return {
          name,
          x: node.position.x,
          y: node.position.y
        };
      })
    };
    e.preventDefault();
  }
});

fetchConfigFiles();
LoadAndDraw();
</script>
</body>
</html>